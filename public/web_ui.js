// Generated by CoffeeScript 1.7.1
(function() {
  var webUi;

  webUi = (function($) {
    var addMessage, ajax, buildAction, buildMenu, handleMessage, handleMessages, init, menu_, method_, nodeFromData, nodesFromData, notice, removeMessage, types_;
    types_ = method_ = menu_ = void 0;
    ajax = {
      buildTree: function() {
        var $msg;
        $msg = addMessage('Getting tree...', 'load');
        return $.get(method_.tree_url, {
          type: 'tree'
        }).done(function(data) {
          var e, nodes;
          try {
            nodes = nodesFromData($.isArray(data) ? data : [data]);
            return $('#tree').jstree({
              core: {
                data: nodes
              },
              contextmenu: {
                items: menu_
              },
              plugins: ['contextmenu', 'dnd', 'types', 'wholerow'],
              types: types_
            });
          } catch (_error) {
            e = _error;
            return addMessage("Fatal Error: " + e, 'error');
          }
        }).fail(function() {
          return addMessage('Fatal Error: Could not get tree from server.', 'error');
        }).always(function() {
          return removeMessage($msg);
        }).always(handleMessages);
      },
      executeAction: function(key, node) {
        return console.debug(key, node, $('#tree').jstree().get_node(node.reference));
      }
    };

    /* addMessage(Str text, Str classes?)
    Shows a message with the given text. Additional CSS classes may be given as a
    space-separated string. Returns the message's $div.
     */
    addMessage = function(text, classes) {
      var $div;
      $div = $('<div class="message"></div>').text(text).hide();
      if (classes) {
        $div.addClass(classes);
      }
      return $div.appendTo('#messages').slideDown();
    };

    /* removeMessage($div)
    Hides and removes the given message. Returns the $div to be removed after it gets done
    sliding up, whatever good that'll do ya. You should probably just leave it alone.
     */
    removeMessage = function($div) {
      return $div.slideUp({
        complete: function() {
          return $div.remove();
        }
      });
    };

    /* notice(Str text, Str classes?)
    Dispatches to addMessage, waits five seconds and then calls removeMessage. Happens to
    return the timeout ID of the five-second wait.
     */
    notice = function(text, classes) {
      var $div;
      $div = addMessage(text, classes);
      return setTimeout((function() {
        return removeMessage($div);
      }), 5000);
    };

    /* handleMessage(Str|{Str :text, Str :type} msg)
    Defers to notice. I can't explain it simpler or shorter than the code.
     */
    handleMessage = function(msg) {
      if (typeof msg === 'string') {
        notice(msg);
      } else {
        notice(msg.text, msg.type);
      }
    };

    /* handleMessages({Object|[Object] :messages} data)
    Defers to handleMessage for each message in the given data, if that object has a
    ``messages'' property. It may either be a single message or an array of them.
     */
    handleMessages = function(data) {
      var m, messages, _i, _len;
      if (data && 'messages' in data && (messages = data.messages)) {
        if ($.isArray(messages)) {
          for (_i = 0, _len = messages.length; _i < _len; _i++) {
            m = messages[_i];
            handleMessage(m);
          }
        } else {
          handleMessage(messages);
        }
      }
    };
    nodeFromData = function(data) {
      var arg, args, formatted, i, node, type, _i, _len, _ref;
      type = types_[data.type] || (function() {
        throw "Unknown type: " + data.type;
      })();
      if ('printf' in type) {
        args = [];
        _ref = type.printf.args;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          arg = _ref[i];
          args[i] = data[arg];
        }
        formatted = vsprintf(type.printf.format, args);
      }
      node = {
        type: data.type,
        id: data.id,
        text: formatted || data.text
      };
      if ('state' in data) {
        node['state'] = data.state;
      }
      if ('children' in data) {
        node['children'] = nodesFromData(data.children);
      }
      return node;
    };
    nodesFromData = function(list) {
      var n, nodes, _i, _len;
      nodes = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        n = list[_i];
        nodes.push(nodeFromData(n));
      }
      return nodes;
    };
    buildAction = function(key, value, separator) {
      var action;
      action = {
        action: function(node) {
          return method_.executeAction(key, node);
        }
      };
      if (typeof value === 'string') {
        action['label'] = value;
      } else {
        action['label'] = value.text || (function() {
          throw "Missing text for action " + k;
        })();
        if ('icon' in value) {
          action['icon'] = value.icon;
        }
      }
      if (separator) {
        action['separator_before'] = true;
      }
      return action;
    };
    buildMenu = function(types, actions) {
      var a, menus, separator, t, v, _i, _len, _ref;
      menus = {};
      separator = false;
      for (t in types) {
        v = types[t];
        menus[t] = {};
        _ref = v.actions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          a = _ref[_i];
          if (a) {
            if (!a in actions) {
              throw "Unknown action: " + a;
            }
            menus[t][a] = buildAction(a, actions[a], separator);
            separator = false;
          } else {
            separator = true;
          }
        }
      }
      return function(node) {
        return menus[node.type];
      };
    };

    /* init()
    Loads the configuration information from the server via AJAX and then does a bunch of
    ugly error checking. If it's happy with the result, it defers to buildTree. Otherwise
    it shows a message and the script dies. Then you go fix your broken server code.
     */
    return init = function() {
      var $msg;
      $msg = addMessage('Getting server configuration...', 'load');
      return $.get('/', {
        type: 'config'
      }).done(function(_arg) {
        var actions, e, errs, es, method, types, _i, _len;
        method = _arg.method, types = _arg.types, actions = _arg.actions;
        try {
          errs = [];
          switch (method.name) {
            case 'ajax':
              'tree_url' in method || errs.push('ajax missing tree_url.');
              'action_urls' in method || errs.push('ajax missing action_urls.');
              if (errs.length) {
                break;
              }
              ajax.tree_url = method.tree_url;
              ajax.action_urls = method.action_urls;
              method_ = ajax;
              break;
            default:
              errs.push("Unsupported method: " + method.name);
          }
          if (!types) {
            errs.push('Server did not return valid types.');
          }
          if (!actions) {
            errs.push('Server did not return valid actions.');
          }
          if (errs.length) {
            throw errs;
          }
          types_ = types;
          menu_ = buildMenu(types, actions);
          method_.buildTree();
        } catch (_error) {
          es = _error;
          if ($.isArray(es)) {
            for (_i = 0, _len = es.length; _i < _len; _i++) {
              e = es[_i];
              addMessage("Fatal Error: " + e, 'error');
            }
          } else {
            addMessage("Fatal Error: " + es, 'error');
          }
          throw es;
        }
      }).fail(function() {
        return addMessage('Fatal Error: Could not get server configuration.', 'error');
      }).always(function() {
        return removeMessage($msg);
      }).always(handleMessages);
    };
  })(jQuery);

  jQuery(webUi);

  jQuery(function() {
    return jQuery('.noscript').remove();
  });

}).call(this);
